defmodule WidgetWorkbench.ComponentGenerator do
  @moduledoc """
  Runtime generator for creating new Scenic widget components.

  Generates app-agnostic, reusable components following the MenuBar architectural pattern:
  - 4 component files (component, state, reducer, renderer)
  - 1 spex test file with basic load + interaction tests

  ## Usage

      WidgetWorkbench.ComponentGenerator.generate("my_widget")
      # => {:ok, ["lib/components/my_widget/my_widget.ex", ...]}
  """

  @doc """
  Generate a new component with the standard 4-file structure + spex test.

  ## Parameters
  - `component_name` - Snake_case name for the component (e.g., "my_widget")

  ## Returns
  - `{:ok, [file_paths]}` - Success with list of created files
  - `{:error, reason}` - Validation or file creation error
  """
  def generate(component_name) do
    with {:ok, normalized_name} <- validate_and_normalize(component_name),
         {:ok, paths} <- check_paths_available(normalized_name),
         :ok <- create_directories(paths),
         :ok <- create_component_files(normalized_name, paths),
         :ok <- create_spex_file(normalized_name, paths) do
      {:ok, list_created_files(paths)}
    end
  end

  # Validation and normalization
  defp validate_and_normalize(name) when is_binary(name) do
    normalized = name |> String.trim() |> String.downcase() |> String.replace(~r/[^a-z0-9_]/, "_")

    cond do
      String.length(normalized) == 0 ->
        {:error, "Component name cannot be empty"}

      String.match?(normalized, ~r/^[0-9]/) ->
        {:error, "Component name cannot start with a number"}

      String.contains?(normalized, "__") ->
        {:error, "Component name cannot contain consecutive underscores"}

      true ->
        {:ok, normalized}
    end
  end

  defp validate_and_normalize(_), do: {:error, "Component name must be a string"}

  # Check that component directory doesn't already exist
  defp check_paths_available(name) do
    component_dir = Path.join([File.cwd!(), "lib", "components", name])
    spex_dir = Path.join([File.cwd!(), "test", "spex", name])

    cond do
      File.exists?(component_dir) ->
        {:error, "Component directory already exists: #{component_dir}"}

      File.exists?(spex_dir) ->
        {:error, "Spex directory already exists: #{spex_dir}"}

      true ->
        {:ok, %{
          component_dir: component_dir,
          spex_dir: spex_dir,
          component_file: Path.join(component_dir, "#{name}.ex"),
          state_file: Path.join(component_dir, "state.ex"),
          reducer_file: Path.join(component_dir, "reducer.ex"),
          renderer_file: Path.join(component_dir, "renderer.ex"),
          spex_file: Path.join(spex_dir, "#{name}_basic_spex.exs")
        }}
    end
  end

  defp create_directories(%{component_dir: comp_dir, spex_dir: spex_dir}) do
    File.mkdir_p!(comp_dir)
    File.mkdir_p!(spex_dir)
    :ok
  end

  defp create_component_files(name, paths) do
    module_name = Macro.camelize(name)

    File.write!(paths.component_file, component_template(name, module_name))
    File.write!(paths.state_file, state_template(name, module_name))
    File.write!(paths.reducer_file, reducer_template(name, module_name))
    File.write!(paths.renderer_file, renderer_template(name, module_name))

    :ok
  end

  defp create_spex_file(name, paths) do
    module_name = Macro.camelize(name)
    File.write!(paths.spex_file, spex_template(name, module_name))
    :ok
  end

  defp list_created_files(paths) do
    [
      paths.component_file,
      paths.state_file,
      paths.reducer_file,
      paths.renderer_file,
      paths.spex_file
    ]
  end

  # ============================================================================
  # Component Template
  # ============================================================================

  defp component_template(name, module_name) do
    """
    defmodule ScenicWidgets.#{module_name} do
      @moduledoc \"\"\"
      A #{name} component for Scenic applications.

      Generated by Widget Workbench - a Widgex component template.

      ## Usage

          graph
          |> ScenicWidgets.#{module_name}.add_to_graph(
            %{frame: frame},
            id: :my_#{name}
          )

      ## Features
      - Hover highlighting (demonstrates cursor tracking)
      - Click to toggle background color (demonstrates state transitions)
      - Retained-mode rendering with incremental updates

      ## Events
      This component sends the following events to its parent:
      - `{:#{name}_clicked, component_id}` - When the component is clicked
      \"\"\"

      use Scenic.Component, has_children: false
      require Logger

      alias ScenicWidgets.#{module_name}.{State, Reducer, Renderer}
      alias Scenic.Graph

      @impl Scenic.Component
      def validate(%Widgex.Frame{} = frame) do
        # Component called with bare Widgex.Frame (Widget Workbench pattern)
        {:ok, frame}
      end

      def validate(%{frame: %Widgex.Frame{}} = data) do
        # Component called with map containing :frame key
        {:ok, data}
      end

      def validate(data) when is_map(data) do
        # Fallback for other map formats
        case Map.get(data, :frame) do
          %{pin: _, size: _} ->
            {:ok, data}
          _ ->
            {:error, "#{module_name} requires :frame (Widgex.Frame struct) or map with :frame key"}
        end
      end

      def validate(_), do: {:error, "#{module_name} requires Widgex.Frame or map with :frame"}

      @impl Scenic.Scene
      def init(scene, data, _opts) do
        state = State.new(data)
        graph = Renderer.initial_render(Graph.build(), state)

        scene =
          scene
          |> assign(state: state, graph: graph)
          |> push_graph(graph)

        # request_input returns :ok, not scene - don't pipeline it
        request_input(scene, [:cursor_pos, :cursor_button])

        Logger.debug("#{module_name} initialized: \#{inspect(state)}")

        {:ok, scene}
      end

      @impl Scenic.Scene
      def handle_input(input, _context, scene) do
        state = scene.assigns.state

        case Reducer.process_input(state, input) do
          {:noop, ^state} ->
            # State unchanged, skip update
            {:noreply, scene}

          {:noop, new_state} ->
            # State changed, update graph
            update_scene(scene, state, new_state)

          {:event, event_data, new_state} ->
            # Send event to parent and update
            send_parent_event(scene, event_data)
            update_scene(scene, state, new_state)
        end
      end

      defp update_scene(scene, old_state, new_state) do
        graph = Renderer.update_render(scene.assigns.graph, old_state, new_state)
        scene = assign(scene, state: new_state, graph: graph) |> push_graph(graph)
        {:noreply, scene}
      end
    end
    """
  end

  # ============================================================================
  # State Template
  # ============================================================================

  defp state_template(name, module_name) do
    """
    defmodule ScenicWidgets.#{module_name}.State do
      @moduledoc \"\"\"
      State management for #{module_name} component.

      Contains the data structure and pure query functions (no mutations).
      \"\"\"

      @type t :: %__MODULE__{
        frame: map(),
        hovered: boolean(),
        active: boolean()
      }

      defstruct [
        :frame,
        hovered: false,
        active: false
      ]

      @doc \"\"\"
      Create a new state from initialization data.

      Accepts either:
      - A bare Widgex.Frame struct (Widget Workbench pattern)
      - A map with :frame key containing a Widgex.Frame
      \"\"\"
      def new(%Widgex.Frame{} = frame) do
        # Widget Workbench passes bare frame
        %__MODULE__{
          frame: frame,
          hovered: false,
          active: false
        }
      end

      def new(%{frame: %Widgex.Frame{} = frame}) do
        # Standard pattern with :frame key
        %__MODULE__{
          frame: frame,
          hovered: false,
          active: false
        }
      end

      def new(data) when is_map(data) do
        # Fallback for other formats
        %__MODULE__{
          frame: Map.get(data, :frame),
          hovered: false,
          active: false
        }
      end

      @doc \"\"\"
      Check if a point is inside the component bounds.
      \"\"\"
      def point_inside?(%__MODULE__{frame: %Widgex.Frame{} = frame}, {px, py}) do
        x = frame.pin.x
        y = frame.pin.y
        w = frame.size.width
        h = frame.size.height
        px >= x and px <= x + w and py >= y and py <= y + h
      end

      @doc \"\"\"
      Get the component bounds for semantic registration.
      \"\"\"
      def get_bounds(%__MODULE__{frame: %Widgex.Frame{} = frame}) do
        %{
          left: frame.pin.x,
          top: frame.pin.y,
          width: frame.size.width,
          height: frame.size.height
        }
      end
    end
    """
  end

  # ============================================================================
  # Reducer Template
  # ============================================================================

  defp reducer_template(name, module_name) do
    """
    defmodule ScenicWidgets.#{module_name}.Reducer do
      @moduledoc \"\"\"
      Pure state transition functions for #{module_name}.

      All functions are pure - they take state + input and return {:action, new_state}.
      No side effects or mutations.
      \"\"\"

      alias ScenicWidgets.#{module_name}.State

      @doc \"\"\"
      Process user input and return state transitions.

      Returns:
      - `{:noop, state}` - State may have changed, no external event
      - `{:event, event_data, state}` - Send event to parent + new state
      \"\"\"
      def process_input(%State{} = state, {:cursor_pos, coords}) do
        handle_hover(state, coords)
      end

      def process_input(%State{} = state, {:cursor_button, {:btn_left, 1, [], coords}}) do
        handle_click(state, coords)
      end

      def process_input(state, _input) do
        {:noop, state}
      end

      # Handle hover state
      defp handle_hover(state, coords) do
        currently_hovered = state.hovered
        should_hover = State.point_inside?(state, coords)

        if currently_hovered != should_hover do
          {:noop, %{state | hovered: should_hover}}
        else
          {:noop, state}
        end
      end

      # Handle click
      defp handle_click(state, coords) do
        if State.point_inside?(state, coords) do
          new_active = !state.active
          event_data = {:#{name}_clicked, new_active}
          {:event, event_data, %{state | active: new_active}}
        else
          {:noop, state}
        end
      end
    end
    """
  end

  # ============================================================================
  # Renderer Template
  # ============================================================================

  defp renderer_template(name, module_name) do
    """
    defmodule ScenicWidgets.#{module_name}.Renderer do
      @moduledoc \"\"\"
      Rendering functions for #{module_name}.

      Follows retained-mode pattern:
      - `initial_render/2` - Pre-render all UI elements (including hidden states)
      - `update_render/3` - Incrementally update only changed elements using Graph.modify/3
      \"\"\"

      alias Scenic.{Graph, Primitives}
      alias ScenicWidgets.#{module_name}.State
      import Scenic.Primitives

      @default_color :cornflower_blue
      @active_color :dark_sea_green
      @hover_color :light_sky_blue

      @text_color :white
      @border_width 2

      @doc \"\"\"
      Initial render - create all UI elements.
      Pre-render everything, toggle visibility/styles for state changes.
      \"\"\"
      def initial_render(graph, %State{} = state) do
        graph
        |> render_background(state)
        |> render_border(state)
        |> render_title(state)
        |> render_subtitle(state)
        |> render_clickable_area(state)
      end

      @doc \"\"\"
      Update render - only modify elements that changed.
      Compares old_state vs new_state and updates minimally.
      \"\"\"
      def update_render(graph, %State{} = old_state, %State{} = new_state) do
        graph
        |> update_if_hover_changed(old_state.hovered, new_state.hovered)
        |> update_if_active_changed(old_state.active, new_state.active)
      end

      # ============================================================================
      # Initial Rendering
      # ============================================================================

      defp render_background(%Graph{} = graph, %State{frame: frame} = state) do
        x = frame.pin.x
        y = frame.pin.y
        w = frame.size.width
        h = frame.size.height
        fill_color = if state.active, do: @active_color, else: @default_color

        graph
        |> rect(
          {w, h},
          id: :#{name}_background,
          fill: fill_color,
          translate: {x, y}
        )
      end

      defp render_border(%Graph{} = graph, %State{frame: frame} = state) do
        x = frame.pin.x
        y = frame.pin.y
        w = frame.size.width
        h = frame.size.height
        stroke_color = if state.hovered, do: @hover_color, else: :gray

        graph
        |> rect(
          {w, h},
          id: :#{name}_border,
          stroke: {@border_width, stroke_color},
          fill: :clear,
          translate: {x, y}
        )
      end

      defp render_title(%Graph{} = graph, %State{frame: frame}) do
        x = frame.pin.x
        y = frame.pin.y
        w = frame.size.width

        graph
        |> text(
          "#{module_name}",
          id: :#{name}_title,
          translate: {x + w / 2, y + 30},
          fill: @text_color,
          font_size: 24,
          text_align: :center
        )
      end

      defp render_subtitle(%Graph{} = graph, %State{frame: frame}) do
        x = frame.pin.x
        y = frame.pin.y
        w = frame.size.width

        graph
        |> text(
          "A Widgex component generated with Widget Workbench",
          id: :#{name}_subtitle,
          translate: {x + w / 2, y + 55},
          fill: @text_color,
          font_size: 14,
          text_align: :center
        )
      end

      defp render_clickable_area(%Graph{} = graph, %State{frame: frame} = state) do
        x = frame.pin.x
        y = frame.pin.y
        w = frame.size.width
        h = frame.size.height

        # Render a small interactive indicator
        graph
        |> text(
          click_status_text(state),
          id: :#{name}_status,
          translate: {x + w / 2, y + h - 30},
          fill: @text_color,
          font_size: 16,
          text_align: :center
        )
      end

      # ============================================================================
      # Incremental Updates
      # ============================================================================

      defp update_if_hover_changed(graph, old_hover, new_hover) when old_hover == new_hover do
        graph
      end

      defp update_if_hover_changed(graph, _old_hover, new_hover) do
        stroke_color = if new_hover, do: @hover_color, else: :gray

        graph
        |> Graph.modify(:#{name}_border, fn primitive ->
          Primitives.update_opts(primitive, stroke: {@border_width, stroke_color})
        end)
      end

      defp update_if_active_changed(graph, old_active, new_active) when old_active == new_active do
        graph
      end

      defp update_if_active_changed(graph, _old_active, new_active) do
        fill_color = if new_active, do: @active_color, else: @default_color

        graph
        |> Graph.modify(:#{name}_background, fn primitive ->
          Primitives.update_opts(primitive, fill: fill_color)
        end)
        |> Graph.modify(:#{name}_status, fn primitive ->
          Primitives.text(primitive, click_status_text(%State{active: new_active}))
        end)
      end

      # ============================================================================
      # Helpers
      # ============================================================================

      defp click_status_text(%State{active: true}), do: "âœ“ Active (click to toggle)"
      defp click_status_text(%State{active: false}), do: "Click to activate"
    end
    """
  end

  # ============================================================================
  # Spex Template
  # ============================================================================

  defp spex_template(name, module_name) do
    """
    defmodule ScenicWidgets.#{module_name}.BasicSpex do
      @moduledoc \"\"\"
      Basic specification tests for #{module_name} component.

      Tests:
      - Component loads successfully
      - Hover highlighting works
      - Click toggles background color
      \"\"\"

      use SexySpex

      alias ScenicWidgets.TestHelpers.{SemanticUI, ScriptInspector}

      setup_all do
        # Get environment-specific names
        viewport_name = Application.get_env(:scenic_mcp, :viewport_name, :test_viewport)
        driver_name = Application.get_env(:scenic_mcp, :driver_name, :test_driver)

        # Kill any existing viewport
        if viewport_pid = Process.whereis(viewport_name) do
          Process.exit(viewport_pid, :kill)
          Process.sleep(100)
        end

        # Start application
        Application.ensure_all_started(:scenic_widget_contrib)

        # Configure viewport with all required driver options
        viewport_config = [
          name: viewport_name,
          size: {1200, 800},
          theme: :dark,
          default_scene: {WidgetWorkbench.Scene, []},
          drivers: [[
            module: Scenic.Driver.Local,
            name: driver_name,
            window: [resizeable: true, title: "Test Window"],
            on_close: :stop_viewport,
            debug: false,
            cursor: true,
            antialias: true,
            layer: 0,
            opacity: 255,
            position: [
              scaled: false,
              centered: false,
              orientation: :normal
            ]
          ]]
        ]

        # Start viewport and wait for initialization
        {:ok, viewport_pid} = Scenic.ViewPort.start_link(viewport_config)
        Process.sleep(1500)

        # Cleanup on exit
        on_exit(fn ->
          if pid = Process.whereis(viewport_name) do
            Process.exit(pid, :normal)
            Process.sleep(100)
          end
        end)

        {:ok, %{viewport_pid: viewport_pid}}
      end

      spex "#{module_name} component loads and works" do
        scenario "Load #{module_name} component", context do
          given_ "Widget Workbench is running", context do
            case SemanticUI.verify_widget_workbench_loaded() do
              {:ok, state} ->
                {:ok, Map.put(context, :workbench, state)}
              {:error, reason} ->
                {:error, reason}
            end
          end

          when_ "we load #{module_name}", context do
            case SemanticUI.load_component("#{module_name}") do
              {:ok, result} ->
                Process.sleep(500)  # Wait for component to initialize
                {:ok, Map.put(context, :load_result, result)}
              {:error, reason} ->
                {:error, reason}
            end
          end

          then_ "component should be visible", context do
            # Verify component loaded successfully
            assert context.load_result.loaded == true
            :ok
          end
        end

        scenario "Hover highlighting works", context do
          given_ "#{module_name} is loaded", context do
            # Component already loaded from previous scenario
            {:ok, context}
          end

          when_ "we hover over the component", context do
            # TODO: Implement hover testing once Scenic MCP supports cursor movement
            # For now, this is a placeholder for future implementation
            {:ok, context}
          end

          then_ "component should show hover state", context do
            # TODO: Verify visual hover state changes
            :ok
          end
        end

        scenario "Click toggles background", context do
          given_ "#{module_name} is loaded", context do
            {:ok, context}
          end

          when_ "we click the component", context do
            # TODO: Implement click testing once component has semantic ID
            # For now, this is a placeholder
            {:ok, context}
          end

          then_ "background color should toggle", context do
            # TODO: Verify background color changed
            :ok
          end
        end
      end
    end
    """
  end
end
