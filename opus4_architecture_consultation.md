# Scenic GUI Component Architecture Design Consultation

## Context & Background

I'm building Flamelex - a text editor and memex system in Elixir using the Scenic GUI library. After extensive development, I've reached a critical architectural decision point regarding how to structure reusable GUI components. I need a second opinion on the best path forward.

## Current Architecture Overview

### 6-File Component System

I currently use a 6-file pattern for complex components, auto-generated by `WidgetWorkbench.ComponentBuilder`:

```elixir
# Example: lib/components/todo_list/
├── todo_list_cmpnt.ex      # Main Scenic.Component entry point
├── todo_list_state.ex      # Component state management  
├── todo_list_reducer.ex    # Action processing (Redux-style)
├── todo_list_mutator.ex    # State mutation functions
├── todo_list_render.ex     # Graph rendering logic
└── todo_list_user_input_handler.ex  # Input handling & event routing
```

**Example Component Entry Point:**
```elixir
defmodule ScenicWidgets.TodoList do
  use Scenic.Component
  alias ScenicWidgets.TodoList.{State, Render, Reducer}
  alias Flamelex.Fluxus.RadixState
  
  def validate(%{frame: %Widgex.Frame{}} = data), do: {:ok, data}
  
  def init(scene, %{frame: frame}, _opts) do
    state = Flamelex.Fluxus.RadixStore.get().apps.todo_list
    graph = Render.go(frame, state)
    
    scene
    |> assign(frame: frame, state: state, graph: graph)
    |> push_graph(graph)
    |> subscribe_to_radix_changes()
  end
  
  def handle_info({:radix_state_change, new_state}, scene) do
    # Complex state diffing and selective re-rendering
  end
end
```

### Widgex Framework Integration

All components use the **Widgex** framework for layout and positioning:

```elixir
# Core abstractions:
alias Widgex.Frame                    # Position & size management
alias Widgex.Frame.Grid               # CSS Grid-like layouts  
alias Widgex.Structs.{Coordinates, Dimensions}

# Example usage:
frame = Frame.new(%{pin: {80, 80}, size: {400, 60}})
grid = Grid.new(frame)
  |> Grid.columns([2/3, 1/3])        # 2-column layout
  |> Grid.rows([60, 1])              # Header + flexible content
  |> Grid.calculate()                # Returns positioned cell frames
```

### Global State Management (RadixState)

Components subscribe to a global Redux-style state tree:

```elixir
defmodule Flamelex.Fluxus.RadixState do
  defstruct apps: %{
    todo_list: %TodoList.State{},
    menu_bar: %MenuBar.State{},
    text_editor: %TextEditor.State{}
  }
end

# Components listen for relevant state changes:
def handle_info({:radix_state_change, %{apps: %{todo_list: new_state}}}, scene) do
  # Re-render only if state actually changed
end
```

## The Core Architectural Tension

### Scenic's Philosophy vs. Complex UIs

**Scenic's Approach:** Components handle their own input locally and bubble events up:
```elixir
def handle_input({:cursor_button, :press}, _context, scene) do
  cast_parent(scene, {:button_clicked, :some_data})
  {:noreply, scene}
end
```

**My Requirements:** Top-level input routing based on application state:
```elixir
# In root scene - input behavior depends on editor mode
def handle_input(input, _context, scene) do
  case scene.assigns.vim_mode do
    :insert -> TextEditor.handle_insert_input(input, scene)
    :normal -> TextEditor.handle_normal_input(input, scene)
    :visual -> TextEditor.handle_visual_input(input, scene)
  end
end
```

### Retained Mode Complexity

Scenic uses retained mode graphics - components must update existing graph structures in-place rather than regenerating from pure functions:

```elixir
# Can't just regenerate - must modify existing graph
new_graph = scene.assigns.graph
  |> Graph.modify(:menu_item_3, fn primitive ->
    update_opts(primitive, fill: :red)  # Change color of specific element
  end)
```

This creates complexity in:
1. **State synchronization** between component tree and graph tree
2. **Selective updates** - knowing what changed and updating only those parts
3. **Component isolation** - preventing one component's crash from taking down the system

## Current Pain Points

### 1. Translation Format Incompatibility
```elixir
# Widgex uses structs:
%Widgex.Structs.Coordinates{x: 100, y: 50}

# Scenic expects tuples:
translate: {100, 50}

# Constant conversion needed:
translate: case frame.pin do
  %Coordinates{x: x, y: y} -> {x, y}
  {x, y} -> {x, y}
end
```

### 2. Component Integration Complexity
Different components expect different data formats:
```elixir
# MenuBar expects:
%{frame: frame, menu_map: [...]}

# IconButton expects:  
%{frame: frame, text: "Button"}

# TextEditor expects:
{state, frame}
```

### 3. Event Handling Complexity
```elixir
# Some events MUST be handled locally (hover effects):
def handle_input({:cursor_pos, coords}, _context, scene) do
  # Change button color immediately - can't wait for state update cycle
end

# Other events need global coordination:
def handle_input({:key, {:key_h, 0, []}}, _context, scene) do
  # In Vim normal mode, 'h' moves cursor left
  # But behavior depends on global editor state
end
```

## Previous Attempts at Unification

### Attempt 1: Widgex.Component Macro
```elixir
defmodule MyComponent do
  use Widgex.Component, scrollable: :all_axis
  
  def render(graph, state, frame) do
    # Standard render interface
  end
end
```

**Issues:** Still required manual state management, didn't solve event routing

### Attempt 2: Single-File Components  
Moving back to simpler single-file components with AI assistance for generation.

**Question:** Does AI automation make the 6-file complexity unnecessary?

## Integration Requirements

### Flamelex Integration
Components must integrate seamlessly into the main editor:
```elixir
# Root scene manages multiple components:
def render_main_layout(graph, state) do
  graph
  |> add_component(MenuBar, menu_data, grid.header_frame)
  |> add_component(FileTree, tree_data, grid.sidebar_frame)  
  |> add_component(TextEditor, editor_data, grid.main_frame)
  |> add_component(StatusBar, status_data, grid.footer_frame)
end
```

### Widget Workbench Integration
Components must be testable in isolation:
```elixir
# Load any component dynamically for testing:
def load_component(component_module, test_frame) do
  component_data = prepare_component_data(component_module, test_frame)
  graph |> add_component(component_module, component_data)
end
```

## Specific Examples & Code

### Current MenuBar Implementation
```elixir
defmodule ScenicWidgets.MenuBar do
  use Scenic.Component
  
  def validate(%{frame: %Widgex.Frame{}, menu_map: _} = data) do
    {:ok, data}
  end
  
  def init(scene, %{frame: frame, menu_map: menu_map}, opts) do
    # Complex validation and setup...
    graph = render_menu_structure(frame, menu_map, opts)
    
    scene
    |> assign(frame: frame, menu_map: menu_map)
    |> push_graph(graph)
    |> request_input([:cursor_pos, :cursor_button])
  end
  
  # Hover handling MUST be local for responsiveness:
  def handle_input({:cursor_pos, coords}, _context, scene) do
    # Immediate visual feedback for hover states
    new_graph = update_hover_state(scene.assigns.graph, coords)
    {:noreply, scene |> assign(graph: new_graph) |> push_graph(new_graph)}
  end
  
  # But clicks need to bubble up:
  def handle_input({:cursor_button, :press}, _context, scene) do
    cast_parent(scene, {:menu_item_selected, detect_menu_item(coords)})
    {:noreply, scene}
  end
end
```

### Component Builder Generated Structure
```elixir
# Auto-generated from component name:
defmodule ScenicWidgets.TodoList.Render do
  def go(%Widgex.Frame{} = frame, %State{} = state) do
    Scenic.Graph.build()
    |> Scenic.Primitives.group(fn graph ->
      graph
      |> Draw.background(frame, :medium_slate_blue)
      |> render_todo_items(state.items, frame)
      |> render_add_button(frame)
    end, translate: frame.pin.point)
  end
end

defmodule ScenicWidgets.TodoList.UserInputHandler do
  def handle(rdx, {:click, :add_button}) do
    {:action, {:todo_list, :add_item, %{text: "New item"}}}
  end
  
  def handle(rdx, {:click, {:delete_item, item_id}}) do
    {:action, {:todo_list, :delete_item, item_id}}
  end
end
```

## Key Questions for Architectural Decision

### 1. Component Structure Approach
**Option A:** Keep 6-file system for complex components, provides clear separation
**Option B:** Move to single-file with AI generation assistance  
**Option C:** Create unified `Widgex.Component` wrapper that handles common patterns

### 2. Data Format Standardization
**Should I:** 
- Force all components to use Widgex structs internally and convert at Scenic boundary?
- Create adapter layer that handles format conversion automatically?
- Abandon Widgex structs and use Scenic's tuple format throughout?

### 3. Event Handling Strategy  
**How to balance:**
- Local component autonomy (hover, immediate visual feedback)
- Global state coordination (vim modes, application state)
- Performance (minimal re-rendering, efficient updates)

### 4. State Management Integration
**Current approaches:**
- RadixState subscription with complex diffing
- Direct component state with manual synchronization  
- Hybrid approach with local + global state

### 5. Component Discovery & Loading
**For Widget Workbench dynamic loading:**
- Standardized component interface/protocol?
- Runtime component validation?
- Graceful failure and isolation?

## Request for Opus 4

Given this comprehensive context, I need your architectural expertise on:

1. **What's the most maintainable approach** for component structure going forward?
2. **How should I handle the Scenic vs. Widgex format tension** - convert at boundaries or standardize on one?
3. **What's the best pattern for event handling** that balances local autonomy with global coordination?
4. **Should I continue with the 6-file pattern** or simplify given AI assistance for code generation?
5. **How can I create a unified component interface** that works for both Flamelex integration and Widget Workbench testing?

Please consider:
- Long-term maintainability with a team
- Performance implications of different approaches  
- Compatibility with Scenic's design philosophy
- Testability and component isolation
- Developer experience when creating new components

The goal is a component architecture that enables building complex, responsive GUIs while maintaining clean separation of concerns and good developer ergonomics.